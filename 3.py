# 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (add()), вычитание (sub()),
# умножение (mul()), деление (truediv()). Данные методы должны применяться только к клеткам и выполнять увеличение,
# уменьшение, умножение и целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух
# клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух
# клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек
# этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества
# ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.

class Cell:
    def __init__(self, cel_num):
        self.cel_num = cel_num

    def __str__(self):
        return str(self.cel_num)

    def __add__(self, other):
        new_cel = self.cel_num + other.cel_num
        return new_cel

    def __sub__(self, other):
        new_cel = self.cel_num - other.cel_num
        if new_cel <= 0:
            return f"Недопустимая операция"
        return new_cel

    def __mul__(self, other):
        new_cel = self.cel_num * other.cel_num
        return new_cel

    def __truediv__(self, other):
        new_cel = self.cel_num // other.cel_num
        return new_cel

    def make_order(self, num_in_row):
        cell_order = ""
        current_cells = self.cel_num
        for x in range(self.cel_num // num_in_row):  # Задаём количество полных рядов
            if current_cells == num_in_row:  # Проверяем , является ли ряд последним, чтобы не добавлять \n в конец
                break
            cell_order = cell_order + "*" * num_in_row + '\n'  # Забиваем ряд *
            current_cells = current_cells - num_in_row  # Опрелеям оставшееся количество * для размещения
        cell_order = cell_order + "*" * current_cells  # Добовляем оставшиеся *
        return cell_order


c1 = Cell(7)
c2 = Cell(5)
c3 = Cell(c1 + c2)
c4 = Cell(c1 - c2)
c5 = Cell(c1 * c2)
c6 = Cell(c3 / c2)

a = Cell.make_order(c5, 8)

print(a)
